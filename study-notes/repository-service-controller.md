# 레파지토리, 서비스, 컨트롤러 계층

## 레파지토리 계층

### 어노테이션

- @Repository : 레파지토리 선언
- @RequiredArgsConstructor : final이 붙은 변수들을 포함해 기본 생성자를 자동으로 생성한다. 엔티티 매니저 등의 어트리뷰트에 final 키워드를 잊지 않도록 주의할 것

### 엔티티 매니저

```
private final EntityManager em;
```

- 레파지토리 계층의 경우 위의 코드에서 자동으로 주입받은 엔티티 매니저를 통해 레포지토리를 관리한다!
- em.persist : 새 객체 저장
- em.merge : 병합 → 일종의 업데이트 개념. 추후 아래의 서비스 계층 정리에서 더티 채킹과 함께 설명할 예정
- em.createQuery : 직접 원하는 쿼리를 생성해 날릴 수 있다
- JPQL : SQL과 거의 비슷. 엔티티 객체를 대상으로 쿼리를 날린다 (SQL은 테이블을 상대로 쿼리를 날림)
> 참고 : JPA 레파지토리를 상속받을 시 메소드명을 올바르게 선언하는 것만으로 쿼리문의 작성을 생략할 수 있다. JPA에 대한 이해를 마친 이후 편리성을 위해 사용하는 걸 추천한다

<br/>

## 서비스 계층
주로 컨트롤러 클래스의 호출을 받는다. 필요한 경우 레파지토리 클래스들을 불러와 DB를 조작한다

### 어노테이션

- @Service : 서비스 선언
- @Transactional : 해당 클래스/메소드의 모든 작업이 트렌젝션 위에서 발생하도록 처리한다
  - readOnly = true 옵션 : 읽기 모드 설정. 조회만을 실행하게 될 때 성능을 더 최적화해준다. 조회 이외에 삽입/삭제 시 해당 옵션을 반드시 삭제하여야 한다.
- @RequiredArgsConstructor : final이 붙은 변수들을 포함해 기본 생성자를 자동으로 생성한다. 레파지토리 등의 어트리뷰트에 final 키워드를 잊지 않도록 주의할 것

### Merge
- 병합
- DB 내에서 같은 id를 가진 객체를 찾은 뒤 파라미터로 받은 객체 내의 값으로 모두 바꿔치기 한다
- 파라미터로 넘어온 준영속 객체의 내용을 DB 내 영속성 객체에 덮어쓰기 하는 방식 
- 이후 업데이트가 완료된 영속성 객체를 반환 
- 더티 채킹의 경우 변화가 있는 속성만 선택적으로 변경 
- 그러나 merge의 경우 준영속 객체의 내용을 모두 덮어쓰기 하는 방식으로 병합 시 값을 정해주지 않은 필드는 null로 업데이트 된다! 
- 해당 위험으로 인해 변경 감지보다는 더티 채킹 기능을 사용할 것 
- 즉, 컨트롤러에서 함부로 엔티티를 새로 만들지 말 것 (새로 만든 엔티티는 준영속 객체가 되어 기존 DB 내 객체의 id를 가지고 있지만 JPA의 추적을 받지 못한다)
- 서비스 계층에서 기존의 영속성 객체를 불러와 해당 내용을 변경하는 방식이 권장된다

### 더티 채킹
- 변경 감지
- 영속성 객체의 내용을 바꾸면 JPA는 더디 채킹 기능을 사용해 DB에 해당 내용을 반영한다
- 자동으로 변경 쿼리가 생성됨
- 가장 간단하게 보자면 아래와 같은 흐름이 권장된다
> 요약 : 컨트롤러에서 변경 사항 발생 → 서비스 클래스의 업데이트 메소드 호출→ 서비스 메소드 내에서 영속성 객체 불러오기 → 엔티티 계층의 업데이트 메소드 호출 → 엔티티 계층에서 해당 사항 변경됨 <br/>

- 주의 : 엔티티 클래스 내부에서는 되도록 세터보다 의미를 가진 메소드(update 메소드 등)를 만들어 사용할 것. 추후 메소드 추적이 어려울 수 있다

### 컨트롤러 계층과의 구분
- 서비스 클래스를 작성하다 보면 리파지토리 클래스의 메소드들을 그대로 사용하게 되는 경우가 있다 (수정, 삭제, 리스트 불러오기 등의 간단한 작업)
- 이런 경우 서비스 클래스를 따로 만들 필요 없이, 컨트롤러에서 리파지토리 클래스를 바로 가져와서 사용하는 방법을 고려해 볼 수 있다
- 계층 간 구분이 약해지지만 쓸데없는 코드를 줄일 수 있다는 장점이 존재한다
- 물론 간단한 작업이라도 서비스 계층을 거치는 편이 유지/보수에 좋다는 의견도 다수
- 즉 설계 원칙을 지키는 것만큼이나 유연한 설계를 하는 것이 중요하다

<br/>

## 컨트롤러 계층
- 컨트롤러 클래스에서는 리파지토리 계층의 메소드와 서비스 계층의 메소드를 호출하고 이를 연결하는 식의 역할이 권장된다

### 폼 객체
- 엔티티와 별개로 화면을 위해 사용된다
- 웹 폼을 위한 DTO 
- 여러 필드를 하나의 객체로 묶어서 처리 
- 비즈니스 로직과 분리된 '순수 데이터' 구조
- 엔티티 클래스가 간결하게 유지될 수 있도록 돕는다
