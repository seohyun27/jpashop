# 도메인 설계와 DB

## 엔티티와 값 타입(Value Type)

### 엔티티
데이터베이스에서 테이블과 1:1로 매핑되는 객체

### Value Type
- 엔티티가 가진 속성 중 하나로 사용되는 객체
- 여러 타입의 변수를 묶어 하나의 타입으로 만들어냄 → C언어의 struct와 비슷한 개념
- 엔티티처럼 PK(고유 식별자)를 갖지 않다
- 여러 엔티티에 걸쳐 재사용될 수 있다
- 테이블의 복잡도를 낮춘다
- '임베디드 타입'이라 부르기도 한다 → Value Type 객체는 반드시 다른 엔테테의 테이블 안에 포함되어 저장되기 때문
- 테이블 생성 시 Value Type의 각 값이 테이블 내의 각 칼럼으로 만들어져 들어간다

<br/>

## 엔티티 테이블 설계

- M : N 관계를 사용하지 말 것
- 중간에 두 클래스를 연결하는 연결 클래스를 하나 더 두어서 N : N 관례를 1 : N + N : 1 관계로 풀어서 작성해야 한다
- 양방향 연관관계(1 : N)는 가급적 지양 → 되도록이면 단방향 연관관계만 사용할 것

<br/>

## 양방향 연관관계

### 외래 키
- DB에서 다른 테이블의 기본 키(PK)를 참조하기 위해 존재하는 칼럼
- 두 테이블 간의 관계를 표현하기 위해 사용된다

### 외래 키의 관리
- 양방향 연관관계의 경우에는 주인이 필요하다 (= 누가 외래 키를 관리할 것인가)
- 외래 키를 가진 쪽은 관계의 주인이 되어 관계를 저장하고 수정한다
- 주인이 아닌 쪽은 단순히 읽기 전용으로 사용된다
- 일대일(1 : 1) 양방향 연관관계의 경우 어느 쪽이 외래 키를 가지고 주인이 되든 크게 상관이 없다. 되도록 시스템이 많이 접근하는 쪽에 외래 키를 줄 것이 권장된다
- 다대일(1 : N) 양방향 연관관계의 경우 항상 N쪽이 외래 키를 가지게 된다

### 예시
#### ex1) Member 클래스와 Order 클래스가 존재
- 사람의 관점에서 보면 멤버가 주문을 하는 것처럼 보인다
- 그러나 시스템의 관점에서는 주문 클래스 내부에 주문을 한 멤버가 존재한다
- 즉, 클래스적 관점에서 주문이 멤버를 가지고 있는 것!
- 만약 멤버의 주문 리스트가 필요하다면 주문_레파지토리에서 멤버를 통한 필터링을 사용하면 된다

#### ex2) 자동차 클래스와 바퀴 클래스가 존재
- 하나의 자동차에 여러 바퀴가 필요하다. 그러므로 바퀴의 쪽이 N이 되므로 외래 키를 가지고 연관관계의 주인이 된다

### 어노테이션
JPA 구현에서는 어노테이션을 통해 외래 키에 매핑이 가능하다
```
@JoinColumn(name = "member_id")
private Member member;
```
Order 테이블의 member_id(FK) 컬럼과 해당 변수를 매핑. 해당 필드가 Order → Member 방향의 연관관계 필드가 된다

<br/>

## 단방향 연관관계

그러나 위의 예시 1번에서 Member ↔ Order 사이 멤버가 주문 필드를 가져야 할 이유는 없다. 멤버별 주문 목록이 필요할 때는 레포지토리 쿼리를 조회하는 것만으로 충분하기 때문이다.<br/>
따라서 이 경우 Order → Member 단방향 관계만을 두고 Member에는 주문 목록 필드를 아예 두지 않는 것이 좋다.

```
@ManyToOne
@JoinColumn(name = "member_id")
private Member member;
```

위의 코드처럼 Order 클래스에만 member 필드를 두어 **연관관계의 종류 명시(@ManyToOne)**와 **외래 키 매핑(@JoinColumn)**만 해주면 된다.

<br/>

## 엔티티 구현

엔티티 클래스 구현의 경우 가급적 게터 메소드는 열어두고 세터 메소드는 닫아두는 편이 좋다 → 엔티티의 값을 변경할 때는 비즈니스 로직을 거치는 편이 안전하기 때문이다

### PK 필드

DB 테이블의 식별 id로 사용된다

```
@Id
@GeneratedValue 				// 기본 키 자동 생성 
@Column(name = "member_id")	// DB에서의 칼럼명을 "member_id"로 매핑
```


### 내장 타입 필드

해당 필드의 내용은 내 테이블 내부에 저장되는 내장 클래스임을 명시한다

```
@Embedded
private Address address;
```
값 타입 클래스에는 @Embeddable 어노테이션이 붙어야 한다. 또한 스스로 테이블을 만들지 않음으로 PK 필드를 만들 필요가 없다


### 외래 키 매핑
- 다른 엔티티와의 연관관계가 존재함 + 외래 키 매핑
- 해당 필드의 내용은 다른 테이블의 참조임을 명시
- 주로 외래 키를 가진 주인 쪽이 @ManyToOne을 사용한다

```
@ManyToOne		// 연관관계 명시. 해당 클래스와 해당 필드는 N : 1로 연결되어 있음
@JoinColumn(name = "member_id")	// 해당 외래 키(필드)는 테이블 내부 "member_id"라는 이름으로 칼럼 명이 매핑됨
private Member member;
```

- 양방향 관계일 경우 서류에게 @ManyToOne, @OneToOne 등을 표시
- 주인의 경우 @JoinColumn(name = "") 어노테이션 사용
- 주인이 아닌 쪽의 경우 연관관계 어노테이션 뒤에 (mappedBy = "member") 표기

<br/>

## 테이블 생성
- @Entity가 붙은 클래스를 스캔하고 매핑 정보를 읽는다
- application.yml 또는 application.properties에 DDL 자동 생성 설정이 켜져 있으면 DB 테이블을 자동으로 생성한다
- 컬럼은 @Column 어노테이션을 통해 이름, 길이, null 허용 여부 등을 제어할 수 있다
> 참고 : @Table(name = "테이블명") 어노테이션을 사용해 테이블의 이름을 직접 지정할 수 있지만, 사용하지 않는다면 기본으로 클래스 이름을 사용한다 (Delivery 클래스 → delivery 테이블) <br/>

<br/>

## 설계 시 주의점

### 지연 로딩
- 모든 연관관계는 지연 로딩으로 설정
- 즉시 로딩의 경우 해당 엔티티 상에 존재하는 다른 DB를 함께 불러오게 된다 → 최악의 경우 모든 어플리케이션 내 모든 DB를 한 번에 조회하게 될 수도 있다
- 필요할 때 데이터를 지연 로딩하여 성능 최적화에 유리하다
- 특히 @XToOne(OneToOne, ManyToOne) 관계는 기본이 즉시 로딩! (fetch = FetchType.LAZY)를 통해 지연로딩을 직접 설정해줘야 한다
- 지연 로딩으로 인해 발생하는 문제는 fetch join 또는 엔티티 그래프 기능을 사용하여 해결한다


### DB 컬럼명
- spring boot 기본 전략에 따라 해당 필드의 이름이 DB 컬럼에서는 order_price로 변경된다 (대분자 없음)
- ex) orderPrice →  order_price
- 해당 규칙은 원한다면 다른 방식으로 설정할 수 있다


### cascade 옵션
- cascade는 부모 엔티티의 작업(저장, 삭제 등)을 자식 엔티티에게도 같이 적용하는 것
- 해당 옵션은 두 엔티티가 주인과 종속 관계일 때만 사용하는 게 좋다
- 예를 들어 주문 없이는 주문 아이템도 존재하지 못하기에 cascade를 설정하는 것
- 둘의 관계가 독립적이라면(종속적이지 않다면) 해당 옵션을 사용하지 않는다

```
@OneToMany(mappedBy = "order", cascade = CascadeType.ALL)
private List<OrderItem> orderItems = new ArrayList<>();
```

```
@OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)
@JoinColumn(name = "delivery_id")
private Delivery delivery;
```

- 해당 코드에서 주문을 저장할 때 주문 아이템과 배달도 함께 저장하게 된다
- 주문이 삭제되면 주문 아이템과 배달도 존재할 이유가 없다

- cascade는 외래 키 주인 여부와는 상관없이 단순히 "부모가 자식을 관리할지 여부"만 정하는 옵션

- 외래 키 위치는 DB 규칙: 일대다/다대일에서는 항상 "다(N)" 쪽에 들어간다
- 부모 – 자식 관계는 도메인 규칙: 개발자가 "이 객체 없이는 저 객체가 의미가 없다"라는 식으로 설계해서 정하는 것

<br/>

## 연관관계 메소드

- JPA를 쓸 때 "양방향 연관관계"를 깔끔하게 관리하기 위해 자주 쓰는 패턴
- 두 엔티티의 양방향 관계를 편리하게 설정하고, 일관성을 유지하도록 도와주는 메소드

- 양방향 관계에서 한쪽 엔티티의 필드만 건드리면 DB 등록이 제대로 되지 않는 등의 문제가 발생한다 → 즉, 양쪽 필드를 동시에 세팅해주는 메소드(연관관계 메소드)를 만들어서 실수 없이 관계를 연결하는 것

- ex) order와 member가 서로를 필드로 가지고 있다면 order의 member가 추가될 때 member의 order 필드 역시 추가해야 한다

```
public void setMember(Member member){
    this.member = member;          // Order 객체 안에서 member 참조 연결
    member.getOrders().add(this);   // Member 객체 안에서 order 리스트를 반환. 거기에 자기자신(this = 현재 내 클래스의 객체 = 새 order)를 추가
}
```

핵심적으로 컨트롤을 하는 쪽이 연관관계 메소드를 갖고 있는 게 좋다



